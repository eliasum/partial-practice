/*2021.03.10 17:24 IMM*/

--Переименование столбцов и вычисления в результирующем наборе
	
/*
Имена столбцов, указанные в предложении SELECT, можно переименовать. Это делает результаты более читабельными, поскольку имена полей в
 таблицах часто сокращают с целью упрощения набора. Ключевое слово AS, используемое для переименования, согласно стандарту можно и 
 опустить, так как оно неявно подразумевается.

Например, запрос:
*/

    SELECT ram AS Mb, hd Gb
    FROM PC
    WHERE cd = '24x';

/*
переименует столбец ram в Mb (мегабайты), а столбец hd в Gb (гигабайты). Этот запрос возвратит объемы оперативной памяти и жесткого 
диска для тех компьютеров, которые имеют 24-скоростной CD-ROM:

64 	8
32 	10

Переименование особенно желательно при использовании в предложении SELECT выражений для вычисления значения. Эти выражения позволяют 
получать данные, которые не находятся непосредственно в таблицах. Если выражение содержит имена столбцов таблицы, указанной в 
предложении FROM, то выражение подсчитывается для каждой строки выходных данных. Так, например, чтобы вывести объем оперативной 
памяти в килобайтах, можно написать:
*/

    SELECT ram*1024 AS Kb, hd Gb
    FROM PC
    WHERE cd = '24x';

/*
Теперь будет получен следующий результат:

65536 	8
32768 	10

Иногда бывает необходимо выводить поясняющую информацию рядом с соответствующим значением. Это можно сделать, добавив строковое 
выражение как дополнительный столбец. Например, запрос:
*/

    SELECT ram, 'Mb' AS ram_units, hd, 'Gb' AS hd_units
    FROM PC
    WHERE cd = '24x';

/*
даст следующий результат:

64 	Mb 	8 	Gb
32 	Mb 	10 	Gb

Если же явно не указать имя для выражения, то будет принят способ именования по умолчанию, который зависит от используемой СУБД. 
Так, в MS Access будут использованы имена типа выражение1 и т. д., а выходной столбец в MS SQL Server вообще не будет иметь заголовка.

Согласно стандарту могут использоваться имена с ограничителями (delimited identifier), при этом в качестве ограничителя 
применяется символ двойной кавычки ("). Такой прием допускает присутствие в именах специальных символов и зарезервированных слов.
 Например, запрос
*/

    SELECT 'SELECT' "SELECT";

/*
выведет значение выражения (в данном случае символьную константу 'SELECT') в столбце с именем SELECT. Т.е. мы используем
 зарезервированное слово в качестве имени столбца. Без этого компилятор (SQL Server) не сможет корректно выполнить разбор 
 подобного запроса
*/

    SELECT 'SELECT' SELECT;

/*	
и выдаст такую ошибку:

Incorrect syntax near 'SELECT'.
(некорректный синтаксис возле 'SELECT')

Помимо стандартного ограничителя, различные СУБД допускают использование своих собственных. Например, в SQL Server наш запрос можно
 написать так:
*/

    SELECT 'SELECT' [SELECT];

/*
В то же время, стандартный ограничитель используется параллельно, но не везде он принят настройками по умолчанию. В MSSQL настройку,
 отвечающую за имена с ограничителями, можно изменить с помощью оператора
*/

    SET QUOTED_IDENTIFIER { ON | OFF }

/*	
При этом стандартное поведение (ON) принято по умолчанию.

MySQL

Запрос
*/

    SELECT 'SELECT' "SELECT";

/*
даст в результате выполнения

SELECTSELECT

Это я объясняю тем, что настройки по умолчанию допускают использование символа (") в качестве символа (') для ограничителей строковой
 константы. Поэтому две строки просто сливаются в одну. Однако если написать так
*/

    SELECT 'SELECT' AS "SELECT";

--или так

    SELECT 'SELECT' `SELECT`;

/*
то мы получим требуемый результат.

Чтобы запретить использование двойной кавычки в качестве одинарной, можно поменять настройки на стандартные. Следующий оператор изменит
 настройку, о которой идет речь:
*/

    SET GLOBAL sql_mode='ANSI_QUOTES';

--а этот все настройки сделает стандартными:

    SET GLOBAL sql_mode='ANSI';

--После этого запрос

    SELECT 'SELECT' "SELECT";

--даст

SELECT

/*
Oracle и PostgreSQL

Эти СУБД ведут себя стандартно. Следует лишь отметить, что поскольку Oracle требует присутствия предложения FROM в запросе, наш оператор
 следует написать так:
*/

    SELECT 'SELECT' "SELECT" FROM dual;
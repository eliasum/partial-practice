почему в JS нельзя сразу было сделать так, чтобы контекст this в этом случае не терялся и программисту не приходилось использовать func.call? Зачем эти низкоуровневые проблемы?
Это отличный вопрос, и он затрагивает фундаментальные принципы работы JavaScript. Причина, почему в JavaScript изначально не предусмотрено автоматическое сохранение контекста this, связана с его архитектурой и гибкостью.

Исторические причины:
Гибкость языка:

JavaScript задумывался как лёгкий язык для встраивания в веб-страницы. Контекст this был реализован как универсальный механизм, который зависит от способа вызова функции, а не от её определения. Это делало язык гибким и подходящим для работы с разными объектами.

Минималистичный подход:

Первоначально JavaScript создавался для простых задач и не предполагал таких сложных сценариев. Концепция "привязки контекста" (bind, call, apply) была добавлена позже, чтобы дать программистам больше контроля.

Функциональный стиль:

JavaScript поддерживает функциональное программирование, где функции часто передаются как аргументы. Если бы this всегда автоматически сохранялся, это могло бы ограничить возможности работы с функциями вне их первоначального контекста.

Технические причины:
Универсальность вызовов:

В JavaScript важно различать вызов функции как:

Метода объекта: Здесь this указывает на объект.

Обычной функции: Здесь this может быть undefined (в строгом режиме) или глобальным объектом (в нестрогом режиме).

Снижение путаницы:

Если бы контекст this автоматически сохранялся, то в некоторых случаях это могло бы привести к неожиданным эффектам. Например, при передаче метода как колбэка.

Современные улучшения:
Понимая сложности, в языке появились улучшения:

Стрелочные функции:

Они автоматически связывают this из внешнего контекста:

javascript
let obj = {
  value: 10,
  method: () => console.log(this.value)
};
obj.method(); // this не указывает на obj, а на внешний контекст
Метод bind:

Позволяет явно привязать this к функции:

javascript
let boundFunc = func.bind(context);
Классы:

В ES6 добавлены классы, где методы автоматически имеют контекст объекта.

Почему не избавились от этих проблем?
Обратная совместимость:

JavaScript поддерживает миллионы сайтов и библиотек. Кардинальное изменение поведения this могло бы сломать огромный массив существующего кода.

Гибкость:

Хотя сохранение контекста требует дополнительных усилий, оно позволяет использовать язык в различных сценариях: от объектно-ориентированного до функционального программирования.

Низкоуровневые сложности, такие как управление this, действительно могут казаться трудоёмкими, но они дают программисту больше свободы и контроля.
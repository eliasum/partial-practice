/*2025.03.12 16:53 IMM*/
'use strict';

/*
Декораторы и переадресация вызова, call/apply

JavaScript предоставляет исключительно гибкие возможности по работе с функциями: 
они могут быть переданы в другие функции, использованы как объекты, и сейчас мы 
рассмотрим, как перенаправлять вызовы между ними и как их декорировать.

Прозрачное кеширование
Представим, что у нас есть функция slow(x), выполняющая ресурсоёмкие вычисления,
но возвращающая стабильные результаты. Другими словами, для одного и того же x 
она всегда возвращает один и тот же результат.

Если функция вызывается часто, то, вероятно, мы захотим кешировать (запоминать) 
возвращаемые ею результаты, чтобы сэкономить время на повторных вычислениях.

Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим 
её в функцию-обёртку – «wrapper» (от англ. «wrap» – обёртывать), которая добавит 
кеширование. Далее мы увидим, что в таком подходе масса преимуществ.

Вот код с объяснениями:
*/ 

// Функция slow имитирует медленную операцию
// Она будет выводить сообщение каждый раз, когда вызывается с новым аргументом
function slow(x) {
    // Здесь могли бы быть сложные вычисления
    alert(`Called with ${x}`);
    return x;
}

// Функция-декоратор cachingDecorator добавляет кеширование к любой функции,
// реализует паттерн Декоратор
function cachingDecorator(func) {
    // Создаем объект Map для хранения кешированных результатов
    let cache = new Map();

    // Возвращаем новую функцию, которая оборачивает исходную
    return function(x) {
        // Проверяем, есть ли результат для x в кеше
        if (cache.has(x)) {
            // Если есть, возвращаем его без вызова исходной функции
            return cache.get(x);
        }

        // Если результата нет в кеше, вызываем исходную функцию
        // Это приведет к выводу сообщения "Called with x"
        let result = func(x);

        // Сохраняем результат в кеш для будущих вызовов
        cache.set(x, result);
        return result;
    };
}

// Применяем декоратор к функции slow
// Теперь slow - это новая функция с кешированием
slow = cachingDecorator(slow);

// Первый вызов slow(1) - результат не в кеше, будет выведено сообщение
alert( slow(1) );
// Повторный вызов slow(1) - результат берется из кеша, сообщение не выводится
alert( "Again: " + slow(1) );

// Первый вызов slow(2) - новый аргумент, результат не в кеше, будет выведено сообщение
alert( slow(2) );
// Повторный вызов slow(2) - результат берется из кеша, сообщение не выводится
alert( "Again: " + slow(2) );

// Вызов slow(1) - результат берется из кеша, сообщение не выводится
// Первый вызов slow(2) - новый аргумент, результат не в кеше, будет выведено сообщение
alert( slow(1) );
// Повторный вызов slow(2) - результат берется из кеша, сообщение не выводится
alert( "Again: " + slow(1) );

// Важно понимать:
// 1. Сообщение "Called with x" будет выводиться только для новых значений x
// 2. Если вызвать slow много раз с разными аргументами, сообщение появится для каждого нового аргумента
// Например:
// for (let i = 0; i < 5; i++) {
//     slow(i);  // Выведет сообщение 5 раз, по одному для каждого нового значения i
// }

// В коде выше cachingDecorator – это декоратор, специальная функция, которая
// принимает другую функцию и изменяет её поведение.

// Идея состоит в том, что мы можем вызвать cachingDecorator с любой функцией, в результате 
// чего мы получим кеширующую обёртку. Это здорово, т.к. у нас может быть множество функций,
// использующих такую функциональность, и всё, что нам нужно сделать – это применить к ним cachingDecorator.

// Отделяя кеширующий код от основного кода, мы также сохраняем чистоту и простоту последнего.

// Результат вызова cachingDecorator(func) является «обёрткой», т.е. function(x) «оборачивает»
//  вызов func(x) в кеширующую логику.

// С точки зрения внешнего кода, обёрнутая функция slow по-прежнему делает то же самое. 
// Обёртка всего лишь добавляет к её поведению аспект кеширования.

// Подводя итог, можно выделить несколько преимуществ использования отдельной 
// cachingDecorator вместо изменения кода самой slow:

// Функцию cachingDecorator можно использовать повторно. Мы можем применить её к другой функции.
// Логика кеширования является отдельной, она не увеличивает сложность самой slow (если таковая была).
// При необходимости мы можем объединить несколько декораторов (речь об этом пойдёт позже).
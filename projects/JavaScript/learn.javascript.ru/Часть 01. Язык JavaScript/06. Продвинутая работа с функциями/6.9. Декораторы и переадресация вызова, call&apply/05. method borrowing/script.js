/*2025.04.15 17:53 IMM*/
'use strict';

// Заимствование метода
// Теперь давайте сделаем ещё одно небольшое улучшение функции хеширования:

function hash(args) {
  return args[0] + ',' + args[1];
}
// На данный момент она работает только для двух аргументов. Было бы лучше, 
// если бы она могла склеить любое количество args.

// Естественным решением было бы использовать метод arr.join:

function hash(args) {
  return args.join();
}
// …К сожалению, это не сработает, потому что мы вызываем hash(arguments), 
// а объект arguments является перебираемым и псевдомассивом, но не реальным массивом.

// Таким образом, вызов join для него потерпит неудачу, что мы и можем видеть ниже:

// function hash() {
//   console.log( arguments.join() ); // Ошибка: arguments.join не является функцией
// }

//  hash(1, 2);

// Тем не менее, есть простой способ использовать соединение массива:

function hash() {
  console.log( [].join.call(arguments) ); // 1,2
}

hash(1, 2);

// Этот трюк называется заимствование метода.

// Мы берём (заимствуем) метод join из обычного массива [].join. 
// И используем [].join.call, чтобы выполнить его в контексте arguments.

// Почему это работает?

// Это связано с тем, что внутренний алгоритм встроенного метода arr.join(glue)
// очень прост. Взято из спецификации практически «как есть»:

// Пускай первым аргументом будет glue или, в случае отсутствия аргументов, им будет запятая ","
// Пускай result будет пустой строкой "".
// Добавить this[0] к result.
// Добавить glue и this[1].
// Добавить glue и this[2].
// …выполнять до тех пор, пока this.length элементов не будет склеено.
// Вернуть result.
// Таким образом, технически он принимает this и объединяет this[0], this[1]… и т.д. вместе. 
// Он намеренно написан так, что допускает любой псевдомассив this (не случайно, многие методы 
// следуют этой практике). Вот почему он также работает с this=arguments.
//-------------------------------------------------------------------------------------------------//
// Еще способ:
// Вместо использования arguments.join(), вам нужно сначала преобразовать arguments в массив. 
// Вот два способа сделать это:

// Способ 1: Использование Array.from()

// function hash() {
//   console.log(Array.from(arguments).join());  // Преобразуем в массив и используем join
// }

// hash(1, 2, 3); // Выведет: 1,2,3
// Способ 2: Использование оператора расширения (...)

// function hash() {
//   console.log([...arguments].join());  // Используем оператор расширения для преобразования в массив
// }

// hash(1, 2, 3); // Выведет: 1,2,3
// Почему это работает:
// Array.from(arguments) и [...arguments] создают настоящий массив, используя массивоподобный объект
// arguments. После этого вы можете использовать все методы массива, такие как join().

// Пример с исправлением:

// function hash() {
//   // Преобразуем arguments в массив и выводим через join
//   console.log(Array.from(arguments).join());
// }

// hash(1, 2, 3);  // Выведет: 1,2,3

// Резюме:
// Проблема: arguments — это массивоподобный объект, и у него нет метода join().

// Решение: Преобразуйте arguments в настоящий массив с помощью Array.from() или оператора расширения ....

// Заимствование метода — это когда мы используем методы объектов (например, массивов, строк 
// и т. д.) в контексте другого объекта. В этом случае мы "заимствуем" метод массива, такой 
// как join(), и применяем его к объекту, который не является массивом, но имеет похожую 
// структуру (например, объект arguments).

// Как это работает?
// Рассмотрим этот код:

// function hash() {
//   console.log([].join.call(arguments));  // 1,2
// }

// hash(1, 2);  // Выведет: 1,2

// Шаги, которые происходят:
// Метод join массива: Мы начинаем с пустого массива []. У него есть метод join(), который по 
// умолчанию соединяет все элементы массива в строку, разделяя их запятой. Например:

// [1, 2, 3].join(); // вернет "1,2,3"

// Этот метод не зависит от того, что именно является this (контекстом) при его вызове, то есть
// он может работать с любыми объектами, которые похожи на массивы. Главное, чтобы объект имел 
// свойство length и индексированные элементы (например, this[0], this[1], и т. д.).

// Использование call для изменения контекста: Внутри функции hash мы используем 
// [].join.call(arguments). Функция call позволяет нам изменить контекст метода, т.е. мы указываем,
// что метод join должен работать с объектом arguments, а не с массивом [].

// Таким образом, вместо того, чтобы вызывать join() на пустом массиве, мы говорим: "Примените метод
// join() к объекту arguments."

// Что такое arguments?: Объект arguments — это массивоподобный объект, который автоматически 
// передается в функцию. Он содержит все аргументы, которые были переданы в функцию. Например, в 
// вашем примере, если вы вызываете hash(1, 2), объект arguments будет выглядеть так:

// arguments = { 0: 1, 1: 2, length: 2 }

// Несмотря на то, что это не настоящий массив, у объекта arguments есть свойства length
// и элементы с индексами (arguments[0], arguments[1] и т. д.), что позволяет нам использовать 
// его, как массив.

// Почему это работает?: Метод join массива работает не только с настоящими массивами. Он был
// написан таким образом, что может работать с любыми объектами, у которых есть свойства, 
// похожие на массив, такие как:

// Свойство length

// Индексированные элементы (например, this[0], this[1], и т. д.)

// В коде метода join происходит следующее:

// Он начинает с пустой строки result = "".

// Проходит по всем элементам массива или массива-подобного объекта (например, arguments),
// добавляя их к строке result, разделяя элементы заданным разделителем (по умолчанию — запятой).

// Он продолжает это до тех пор, пока не объединит все элементы объекта.

// Поэтому метод join() может работать с любым массивоподобным объектом (например, с arguments), 
// потому что алгоритм работы метода не зависит от того, является ли this настоящим массивом или нет.
// Он просто ожидает, что объект имеет элементы с индексами и свойство length, и он будет с ними работать.

// Технически, как работает метод join:
// Вот упрощенная версия того, как может выглядеть реализация метода join() (внутренний алгоритм):

// Array.prototype.join = function(glue = ',') {
//   let result = '';
//   for (let i = 0; i < this.length; i++) {
//     if (i > 0) result += glue;  // добавляем разделитель между элементами
//     result += this[i];  // добавляем текущий элемент
//   }
//   return result;  // возвращаем результат
// }

// Почему join() работает с arguments:
// Метод join() может работать с arguments, потому что:

// arguments — это массивоподобный объект, у которого есть свойство length и индексированные 
// элементы (например, arguments[0], arguments[1] и т. д.).

// Внутри метода join нет жесткой привязки к тому, что объект должен быть именно массивом. 
// Главное, чтобы у объекта были элементы, которые можно итерировать (то есть, у объекта есть 
// свойство length и индексы).

// Резюме:
// Мы используем заимствование метода для того, чтобы применять метод массива (join()) к 
// массивоподобному объекту arguments.

// Метод join работает с любыми массивоподобными объектами, потому что он оперирует с элементами  
// через индексы и свойство length.

// Используя call(), мы можем изменить контекст выполнения метода и применить его к arguments,
// как если бы это был обычный массив.

// Это одна из замечательных особенностей JavaScript: вы можете заимствовать методы от других 
// объектов, если они имеют схожие структуры.
//-------------------------------------------------------------------------------------------------//
// Итого
// Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа 
// по-прежнему выполняется функцией.

// Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. 
// Если исходная функция предоставляет свойства, такие как func.calledCount или типа того, то 
// декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным 
// в их использовании. Некоторые декораторы предоставляют свои собственные свойства.

// Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно 
// добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения 
// кода оригинальной функции!

// Для реализации cachingDecorator мы изучили методы:

// func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
// func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как
// список аргументов.
// В основном переадресация вызова выполняется с помощью apply:

// let wrapper = function(original, arguments) {
//   return original.apply(this, arguments);
// };
// Мы также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта в контексте 
// другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments. 
// В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который 
// является реальным массивом.
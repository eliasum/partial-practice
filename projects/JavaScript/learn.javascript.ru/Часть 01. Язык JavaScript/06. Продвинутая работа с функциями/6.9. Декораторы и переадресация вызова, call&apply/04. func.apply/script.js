/*2025.03.31 17:32 IMM*/
'use strict';

// ПЕРЕХОДИМ К НЕСКОЛЬКИМ АРГУМЕНТАМ С «FUNC.APPLY»

// Теперь давайте сделаем cachingDecorator ещё более универсальным. 
// До сих пор он работал только с функциями с одним аргументом.

// Как же кешировать метод с несколькими аргументами worker.slow?

// let worker = {
//   slow(min, max) {
//     return min + max; // здесь может быть тяжёлая задача
//   }
// };

// // будет кешировать вызовы с одинаковыми аргументами
// worker.slow = cachingDecorator(worker.slow);

// Здесь у нас есть две задачи для решения.

// Во-первых, как использовать оба аргумента min и max для ключа в коллекции
// cache? Ранее для одного аргумента x мы могли просто сохранить результат 
// cache.set(x, result) и вызвать cache.get(x), чтобы получить его позже. Но 
// теперь нам нужно запомнить результат для комбинации аргументов (min,max). 
// Встроенный Map принимает только одно значение как ключ.

// Есть много возможных решений:

// Реализовать новую (или использовать стороннюю) структуру данных для коллекции,
// которая более универсальна, чем встроенный Map, и поддерживает множественные ключи.
// Использовать вложенные коллекции: cache.set(min) будет Map, которая хранит пару 
// (max, result). Тогда получить result мы сможем, вызвав cache.get(min).get(max).
// Соединить два значения в одно. В нашем конкретном случае мы можем просто использовать 
// строку "min,max" как ключ к Map. Для гибкости, мы можем позволить передавать 
// хеширующую функцию в декоратор, которая знает, как сделать одно значение из многих.
// Для многих практических применений третий вариант достаточно хорош, поэтому мы будем 
// придерживаться его.

// Также нам понадобится заменить func.call(this, x) на func.call(this, ...arguments), 
// чтобы передавать все аргументы обёрнутой функции, а не только первый.

// Вот более мощный cachingDecorator:

let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
      return cache.get(key);
    }
    /*
    ...arguments:
    arguments — это специальный объект, который содержит все аргументы, переданные в 
    текущую функцию. Это не массив, а объект, который имеет числовые индексы и свойство length.

    ... (spread operator) — это оператор, который "распаковывает" (разворачивает) элементы
     массива или объекта в отдельные значения.

    Когда мы пишем ...arguments, мы распаковываем все элементы объекта arguments и передаем их
     как отдельные аргументы в функцию func.

    Например:

    Если мы вызвали оборачивающую функцию с аргументами 3 и 5, то arguments будет выглядеть как
     объект: { 0: 3, 1: 5, length: 2 }.

    Оператор ...arguments превращает этот объект в отдельные значения: 3, 5, которые 
    передаются в функцию func.
    */
    let result = func.call(this, ...arguments); // (**)

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // работает
alert( "Again " + worker.slow(3, 5) ); // аналогично (из кеша)
// Теперь он работает с любым количеством аргументов.

// Есть два изменения:

// В строке (*) вызываем hash для создания одного ключа из arguments. Здесь
// мы используем простую функцию «объединения», которая превращает аргументы (3, 5)
// в ключ "3,5". В более сложных случаях могут потребоваться другие функции хеширования.
// Затем в строке (**) используем func.call(this, ...arguments) для передачи как 
// контекста, так и всех аргументов, полученных обёрткой (независимо от их количества), 
// в исходную функцию.
// Вместо func.call(this, ...arguments) мы могли бы написать func.apply(this, arguments).

// Синтаксис встроенного метода func.apply:

// func.apply(context, args)

// Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.

// Единственная разница в синтаксисе между call и apply состоит в том, что call ожидает список аргументов,
// в то время как apply принимает псевдомассив.

// Эти два вызова почти эквивалентны:

// func.call(context, ...args); // передаёт массив как список с оператором расширения
// func.apply(context, args);   // тот же эффект

// Есть только одна небольшая разница:

// Оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.
// А apply принимает только псевдомассив args.

// Так что эти вызовы дополняют друг друга. Для перебираемых объектов сработает call, а где 
// мы ожидаем псевдомассив – apply.

// А если у нас объект, который и то, и другое, например, реальный массив, то технически мы
// могли бы использовать любой метод, но apply, вероятно, будет быстрее, потому что 
// большинство движков JavaScript внутренне оптимизируют его лучше.

// Передача всех аргументов вместе с контекстом другой функции называется 
// «перенаправлением вызова» (call forwarding).

// Простейший вид такого перенаправления:

let wrapper = function() {
  return func.apply(this, arguments);
};

// При вызове wrapper из внешнего кода его не отличить от вызова исходной функции.
using System;
using System.Threading;

/*
Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к 
разделяемым ресурсам на время их использования каким-нибудь потоком. Для этого
используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого
весь код блокируется и становится недоступным для других потоков до завершения работы
текущего потока. И мы можем переделать предыдущий пример следующим образом:
*/

class Program
{
    static int x = 0;

    /*
    объект блокировки или объект синхронизации доступа к разделяемому ресурсу
    из нескольких потоков
    */
    static object locker = new object();

    static void Main(string[] args)
    {
        for (int i = 0; i < 5; i++)
        {
            //Делегат - это обьект указывающий на метод.
            //Здесь происходит передача метода Count() новому объекту myThread типа 
            //Thread через новый экземпляр делегата ThreadStart НЕЯВНО (сообщаем метод
            //Count() с делегатом типа ThreadStart). При создании нового потока будет
            //выполняться код из метода Count().
            //Т.е. метод, код которого должен выполняться в другом потоке, передается в 
            //качестве аргумента экземпляру делегата ThreadStart НЕЯВНО, который
            //в свою очередь передается в качестве аргумента экземпляру класса Thread:
            //метод --> экземпляр делегата ThreadStart НЕЯВНО --> объект Thread

            // создаем новый поток (здесь предположение делегата)
            Thread myThread = new Thread(Count);

            // имя нового потока
            myThread.Name = "Поток " + i.ToString();

            // запускаем новый поток
            myThread.Start();
        }

        Console.ReadLine();
    }
    public static void Count()
    {
        /*
        критическая секция - участок кода, в котором происходит попытка
        доступа к разделяемому ресурсу.
        */

        /*Начало*/
        lock (locker)
        {
            x = 1;
            for (int i = 1; i < 9; i++)
            {
                // разделяемый ресурс между потоками
                Console.WriteLine("{0}: {1}", Thread.CurrentThread.Name, x);
                x++;
                Thread.Sleep(100);
            }
        }
        /*Конец*/
    }
}

/*
Для блокировки с ключевым словом lock используется объект-заглушка, в данном случае это 
переменная locker. Когда выполнение доходит до оператора lock, объект locker
блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один
поток. После окончания работы блока кода, объект locker освобождается и становится 
доступным для других потоков.
*/

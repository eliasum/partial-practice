using System;
using System.Threading;

/*
Но тут опять же есть одно ограничение: метод Thread.Start не является типобезопасным, 
то есть мы можем передать в него любой тип, и потом нам придется приводить переданный
объект к нужному нам типу. Для решения данной проблемы рекомендуется объявлять все
используемые методы и переменные в специальном классе, а в основной программе запускать
поток через ThreadStart. Например:
*/

class Program
{
    static void Main(string[] args)
    {
        Counter counter = new Counter(5, 4);

        //Делегат - это обьект указывающий на метод.
        //Здесь происходит передача метода Count() новому объекту myThread типа Thread
        //через новый экземпляр делегата ThreadStart (сообщаем метод Count() с
        //делегатом типа ThreadStart). При создании нового потока будет выполняться 
        //код из метода Count().
        //Т.е. метод, код которого должен выполняться в другом потоке, передается в 
        //качестве аргумента экземпляру делегата ThreadStart, который
        //в свою очередь передается в качестве аргумента экземпляру класса Thread:
        //метод --> экземпляр делегата ThreadStart --> объект Thread

        // создаем новый поток
        Thread myThread = new Thread(new ThreadStart(counter.Count));

        // запускаем новый поток
        myThread.Start();

        // основной поток
        //........................

        Console.ReadLine();
    }
}

public class Counter
{
    //Значения полей с модификатором const при компиляции подставляются в тех местах
    //кода, где к ним происходит обращение. Это значит, что в случае, когда такое поле 
    //объявлено в классе одной сборки, а используется классами другой сборки, для того
    //чтобы измененное значение было применено в зависимой сборке, потребуется 
    //перекомпиляция зависимой сборки. Задать значение можно только в момент
    //объявления. В общем то const-поля это не совсем поля.

    //Поля с модификатором readonly являются полноценными полями, с той разницей, 
    //что изменять их значение разрешено только в конструкторе. Соответственно static
    //readonly - в статическом конструкторе (код инициализации полей при объявлении
    //переносится в конструктор компилятором). Таким образом, значения readonly-полей 
    //могут, например вычисляться на основе параметров переданных в конструктор, 
    //что невозможно для const-полей.

    //В большинстве случаев рекомендуется использовать именно readonly-поля вместо 
    //const-полей когда ваш проект включает более одного модуля.

    private readonly int x;
    private readonly int y;

    public Counter(int _x, int _y)
    {
        this.x = _x;
        this.y = _y;
    }

    public void Count()
    {
        for (int i = 1; i < 9; i++)
        {
            Console.WriteLine("Второй поток:");
            Console.WriteLine(i * x * y);
            Thread.Sleep(400);
        }
    }
}

/*2020.07.11 13:53 IMM*/

//Обобщения

//Кроме обычных типов фреймворк .NET также поддерживает обобщенные типы (generics),
//а также создание обобщенных методов. Чтобы разобраться в особенности данного 
//явления, сначала посмотрим на проблему, которая могла возникнуть до появления 
//обобщенных типов. Посмотрим на примере. Допустим, мы определяем класс для 
//представления банковского счета. К примеру, он мог бы выглядеть следующим образом:

//class Account
//{
//    public int Id { get; set; }
//    public int Sum { get; set; }
//}

//Класс Account определяет два свойства: Id - уникальный идентификатор и Sum - 
//сумму на счете.

//Здесь идентификатор задан как числовое значение, то есть банковские счета будут
//иметь значения 1, 2, 3, 4 и так далее. Однако также нередко для идентификатора 
//используются и строковые значения. И у числовых, и у строковых значений есть 
//свои плюсы и минусы. И на момент написания класса мы можем точно не знать, что 
//лучше выбрать для хранения идентификатора - строки или числа. Либо, возможно, 
//этот класс будет использоваться другими разработчиками, которые могут иметь свое
//мнение по данной проблеме.

//И на первый взгляд, чтобы выйти из подобной ситуации, мы можем определить свойство
//Id как свойство типа object. Так как тип object является универсальным типом, от
//которого наследуются все типы, соответственно в свойствах подобного типа мы можем
//сохранить и строки, и числа:

using System;

namespace Generics01
{
    class Account
    {
        // свойства
        public object Id { get; set; }
        public int Sum { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            /*
            Затем этот класс можно было использовать для создания банковских
            счетов в программе:

            Создаем два экземпляра класса Account:
            */
            Account account1 = new Account();
            account1.Sum = 5000;
            account1.Id = 2;                // упаковка значения int в тип Object

            Account account2 = new Account { Sum = 4000, Id = "4356"};

            int id1 = (int)account1.Id;     // Распаковка типа object в тип int
            string id2 = (string)account2.Id;

            Console.WriteLine(account1.Id);
            Console.WriteLine(id2);

            Console.ReadKey();
        }
    }
}

//Все вроде замечательно работает, но такое решение является не очень оптимальным.
//Дело в том, что в данном случае мы сталкиваемся с такими явлениями как упаковка
//(boxing) и распаковка (unboxing).

//Так, при присвоении свойству Id значения типа int, происходит упаковка этого
//значения в тип Object:

//account1.Id = 2;        // упаковка значения int в тип Object

//Чтобы обратно получить данные в переменную типов int, необходимо выполнить распаковку:

//int id1 = (int)account1.Id;     // Распаковка типа object в тип int

//Упаковка(boxing) предполагает преобразование объекта значимого типа(например, типа 
//int) к типу object. При упаковке общеязыковая среда CLR обертывает значение в 
//объект типа System.Object и сохраняет его в управляемой куче(хипе). 
//Распаковка(unboxing), наоборот, предполагает преобразование объекта типа object к
//значимому типу. Упаковка и распаковка ведут к снижению производительности, так как
//системе надо осуществить необходимые преобразования.
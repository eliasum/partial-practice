/*2022.10.11 14:09 IMM*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//Выше мы определили переменную hello, которая представляет делегат Message. Но начиная с версии C# 10 мы можем 
//применять неявную типизацию (определение переменной с помощью оператора var) при определении лямбда-выражения:

//var hello = () => Console.WriteLine("Hello");
//hello();       // Hello
//hello();       // Hello
//hello();       // Hello

//Но какой тип в данном случае представляет переменная hello? При неявной типизации компилятор сам пытается 
//сопоставить лямбда-выражение на основе его опеределения с каким-нибудь делегатом. Например, выше определенное 
//лямбда-выражение hello по умолчанию компилятор будет рассматривать как переменную встроенного делегата Action,
//который не принимает никаких параметров и ничего не возвращает.

//Параметры лямбды

//При определении списка параметров мы можем не указывать для них тип данных:

namespace DSL03
{
    class Program
    {
        /*
            класс-делегат с именем Operation. Метод, сообщенный с данным делегатом,
            будет принимать два целочисленных параметра и ничего не возвращать 
        */
        delegate void Operation(int x, int y);

        static void Main(string[] args)
        {
            /*
                переменной делегата sum типа Operation присвоить лямбда-выражение,
                которое принимает два целочисленных параметра и ничего не возвращает  
            */
            Operation sum = (x, y) => Console.WriteLine($"{x} + {y} = {x + y}");
            sum(1, 2);          // 1 + 2 = 3
            sum(22, 14);        // 22 + 14 = 36

            Console.ReadKey();
        }
    }
}
//В данном случае компилятор видит, что лямбда-выражение sum представляет тип Operation, а значит оба параметра 
//лямбды представляют тип int. Поэтому никак проблем не возникнет.

//Однако если мы применяем неявную типизацию, то у компилятора могут возникнуть трудности, чтобы вывести тип 
//делегата для лямбда-выражения, например, в следующем случае

//var sum = (x, y) => Console.WriteLine($"{x} + {y} = {x + y}");   // ! Ошибка
//В этом случае можно указать тип параметров

//var sum = (int x, int y) => Console.WriteLine($"{x} + {y} = {x + y}");
//sum(1, 2);       // 1 + 2 = 3
//sum(22, 14);    // 22 + 14 = 36
<!--2021.08.06 15:15 IMM-->
<!--
Файлы отделенного кода

При создании нового проекта WPF в дополнение к создаваемому файлу MainWindow.xaml создается также файл
    отделенного кода MainWindow.xaml.cs, где, как предполагается, должна находится логика приложения,
    связанная с разметкой из MainWindow.xaml. Файлы XAML позволяют нам определить интерфейс окна, но для 
    создания логики приложения, например, для определения обработчиков событий элементов управления, нам 
    все равно придется воспользоваться кодом C#.

По умолчанию в разметке окна используется атрибут x:Class:
    <Window x:Class="XamlApp.MainWindow" 
.......
    
Атрибут x:Class указывает на класс, который будет представлять данное окно и в который будет компилироваться
    код в XAML при компиляции. То есть во время компиляции будет генерироваться класс XamlApp.MainWindow, 
    унаследованный от класса System.Windows.Window.

Кроме того в файле отделенного кода MainWindow.xaml.cs, который Visual Studio создает автоматически, мы также 
    можем найти класс с тем же именем - в данном случае класс XamlApp.MainWindow. 
    
По сути пустой класс, но этот класс уже выполняет некоторую работу. Во время компиляции этот класс объединяется с
    классом, сгенерированном из кода XAML. Чтобы такое слияние классов во время компиляции произошло, класс
    XamlApp.MainWindow определяется как частичный с модификатором partial. А через метод InitializeComponent()
    класс MainWindow вызывает скомпилированный ранее код XAML, разбирает его и по нему строит графический 
    интерфейс окна.
    
Взаимодействие кода C# и XAML

В приложении часто требуется обратиться к какому-нибудь элементу управления. Для этого надо установить у 
    элемента в XAML свойство Name.

Еще одной точкой взаимодействия между xaml и C# являются события. С помощью атрибутов в XAML мы можем задать
    события, которые будут связанны с обработчиками в коде C#.

Итак, создадим новый проект WPF, который назовем XamlApp. В разметке главного окна определим два элемента:
    кнопку и текстовое поле.
-->
    
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800">
    <Grid x:Name="grid1">
        <TextBox x:Name="textBox1" Width="150" Height="30" VerticalAlignment="Top" Margin="20" />
        <Button x:Name="button1"  Width="100" Height="30" Content="Кнопка" Click="Button_Click" />
    </Grid>
</Window>
    
<!--
    Определив имена элементов в XAML, затем мы можем к ним обращаться в коде c#: string text = textBox1.Text.

При определении имен в XAML надо учитывать, что оба пространства имен 
    "http://schemas.microsoft.com/winfx/2006/xaml/presentation" и "http://schemas.microsoft.com/winfx/2006/xaml" 
    определяют атрибут Name, который устанавливает имя элемента. Во втором случае атрибут используется с префиксом
    x: x:Name. Какое именно пространство имен использовать в данном случае, не столь важно, а следующие определения 
    имени x:Name="button1" и Name="button1" фактически будут равноценны.
    (Комментарии: Между атрибутами x:Name и Name всё же есть различия.
Атрибут Name объявляется 1 раз и виден по всей иерархии кода, а x:Name - внутри некоторой локальной области 
    (стиль, шаблон). Так что во избежание ошибок лучше вообще отказаться от использования Name в сторону x:Name.)

В обработчике нажатия кнопки просто выводится сообщение, введенное в текстовое поле. После определения обработчика 
    мы его можем связать с событием нажатия кнопки в xaml через атрибут Click: Click="Button_Click". В результате
    после нажатия на кнопку мы увидим в окне введенное в текстовое поле сообщение.    
-->

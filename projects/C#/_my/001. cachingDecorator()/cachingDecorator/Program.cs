/*2025.03.18 12:08 IMM*/

using System;
using System.Collections.Generic;

// Реализация аналога функции cachingDecorator(func) в JS, используя делегаты и словарь для хранения кеша
/*
function cachingDecorator(func) {
  // Создаем Map для хранения кеша
  let cache = new Map();
  
  // Возвращаем новую функцию
  return function(x) {
    // Если результат для x уже в кеше, возвращаем его
    if (cache.has(x)) {
      return cache.get(x);
    }
    // Иначе вызываем оригинальную функцию
    let result = func.call(this, x); // теперь 'this' передаётся правильно
    // Сохраняем результат в кеш
    cache.set(x, result);
    // Возвращаем результат
    return result;
  };
}
 */

class Program
{
    // Метод-декоратор для добавления кеширования к функции
    // Обобщения <T, TResult> позволяют использовать любые типы аргументов и возвращаемых значений
    /*
    T и TResult — это имена параметров типа, которые являются заменителями для реальных типов данных.
    T (от "Type") обычно используется для обозначения входного типа.
    TResult (от "Result") обычно используется для обозначения возвращаемого типа.
    Эти имена не фиксированы и могут быть произвольными (например, TInput вместо T, 
    или TOutput вместо TResult), но выбираются так, чтобы код был понятным.

    Func<T, TResult> — это стандартный делегат в C# из пространства имен System, который представляет 
    метод, принимающий один или несколько аргументов и возвращающий значение. Его можно использовать 
    для представления функций, указателей на методы или лямбда-выражений.
    */
    public static Func<T, TResult> CachingDecorator<T, TResult>(Func<T, TResult> func)
    {
        // Создаем словарь для хранения кеша
        var cache = new Dictionary<T, TResult>();

        // Возвращаем новую функцию (анонимную функцию или лямбда-выражение), 
        // которая принимает параметр arg типа T (входной аргумент) и
        // добавляет функционал кеширования
        return (arg) =>
        {
            // Проверяем, существует ли уже в кеше результат для данного аргумента
            if (cache.ContainsKey(arg))
            {
                Console.WriteLine($"Результат для аргумента {arg} найден в кеше.");
                return cache[arg]; // Если найден, возвращаем сохраненный результат
            }

            // Если результата в кеше нет, вызываем оригинальную функцию
            Console.WriteLine($"Результат для аргумента {arg} отсутствует в кеше. Вычисляем...");
            var result = func(arg); // Вычисляем результат
            cache[arg] = result; // Сохраняем результат в кеше
            return result; // Возвращаем результат
        };
    }

    static void Main(string[] args)
    {
        // Пример оригинальной функции, которая вычисляет квадрат числа
        Func<int, int> square = x =>
        {
            Console.WriteLine($"Оригинальная функция вызвана с аргументом {x}");
            return x * x;
        };

        // Используем декоратор, чтобы создать кэшируемую версию функции
        var cachedSquare = CachingDecorator(square);

        // Вызов оригинальной функции
        Console.WriteLine("\nВызов оригинальной функции:");
        Console.WriteLine(square(5)); // Оригинальная функция просто выполняет свою работу

        // Вызов кэшируемой функции (первый вызов)
        Console.WriteLine("\nВызов кэшируемой функции (первый раз):");
        Console.WriteLine(cachedSquare(5)); // Кэш отсутствует, вызывается оригинальная функция

        // Вызов кэшируемой функции (второй вызов с тем же аргументом)
        Console.WriteLine("\nВызов кэшируемой функции (второй раз):");
        Console.WriteLine(cachedSquare(5)); // Значение берется из кеша

        // Вызов кэшируемой функции с новым аргументом
        Console.WriteLine("\nВызов кэшируемой функции с новым аргументом:");
        Console.WriteLine(cachedSquare(10)); // Новый аргумент, вызывается оригинальная функция

        Console.ReadKey();
    }
}

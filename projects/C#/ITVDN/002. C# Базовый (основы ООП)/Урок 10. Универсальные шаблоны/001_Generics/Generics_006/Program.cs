/*2020.06.23 19:49 IMM*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// ковариантность обобщений
/*
Понятия ковариантности и контравариантности связаны с возможностью использовать в приложении 
вместо некоторого типа другой тип, который находится ниже или выше в иерархии наследования.

Имеется три возможных варианта поведения:
    Ковариантность: позволяет использовать более конкретный тип, чем заданный изначально
    Контравариантность: позволяет использовать более универсальный тип, чем заданный изначально
    Инвариантность: позволяет использовать только заданный тип

Начиная с .NET 4.0 в C# была добавлена возможность создания ковариантных и контравариантных 
обобщенных интерфейсов. Это функциональность повышает гибкость при использовании обобщенных 
интерфейсов в программе. По умолчанию все обобщенные интерфейсы, например, IAccout<T>
являются инвариантными. 
*/

namespace Generics_005
{
    // создадим абстрактный класс
    /*
    Абстрактный класс в объектно-ориентированном программировании — базовый класс, который
    не предполагает создания экземпляров. Абстрактные классы реализуют на практике один из 
    принципов ООП — полиморфизм. Абстрактный класс может содержать (и не содержать) 
    абстрактные методы и свойства. Абстрактный метод не реализуется для класса, в котором
    описан, однако должен быть реализован для его неабстрактных потомков. Абстрактные 
    классы представляют собой наиболее общие абстракции, то есть имеющие наибольший объём
    и наименьшее содержание.  
    */
    public abstract class Shape { }

    // класс, который наследуется от абстрактного класса Shape
    public class Circle : Shape { }

    // открытый интерфейс IContainer, параметризированный одним указателем места заполнения типом - Т
    /*
    Абстрактные классы могут содержать в себе реализацию некоторых методов, интерфейсы
    содержат только прототипы. 

    Абстрактный класс — это класс, у которого не реализован один или больше методов 
    (некоторые языки требуют такие методы помечать специальными ключевыми словами).

    Абстрактный класс нужен, когда нужно семейство классов, у которых есть много
    общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать 
    много идентичного кода.

    Интерфейс - это форма взаимодействия с любыми классами, которые его реализуют, а 
    абстрактный класс - это предок, который определяет не только особенности поведения
    (методы), но и некоторые аспекты самого объекта (поля/свойства).
    Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все
    они публичные и нет переменных класса.

    интерфейс - это "что необходимо уметь, чтобы такое можно было создать и называть этим 
    именем ("выполняемый", "перечисляемый", "уничтожаемый", ...)". перефразирую. все, кто
    реализуют интерфейс, обязательно (как-то) умеют делать все, что в описании интерфейса
    перечислено. и больше интерфейс не определяет и не имеет ничего!

    Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, 
    один класс хочет дать другому возможность доступа к некоторым своим методам, но
    не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

    Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.
    */
    public interface IContainer<T>
    {
        // в теле интерфейса создаем абстрактное свойство типа указателя места заполнения типом - Т
        T Figure { get; set; }
    }

    // класс Container, параметризированный одним указателем места заполнения типом - Т,
    // который реализует интерфейс IContainer, параметризированный одним указателем места
    // заполнения типом - Т
    public class Container<T> : IContainer<T>
    {
        /*
        реализация абстрактного свойства из интерфейса IContainer<T> в виде
        автоматически реализуемого свойства (автосвойства)
        */
        public T Figure { get; set; }  

        // конструктор, который принимает один аргумент типа указателя места заполнения типом - Т
        public Container(T figure)
        {
            this.Figure = figure;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // создаем экземпляр класса Circle
            Circle circle = new Circle();

            // создаем переменную типа базового интерфейсного типа, закрываем его типом <Shape> и 
            // делаем upcast (повышающее приведение) к нему экземпляра класса Container, который
            // реализует данный интерфейс
            // так же экземпляр circle класса Circle неявно апкастится к базовому абстр. классу Shape
            // таким образом, ковариантность обобщений - это апкаст параметра типа

            /*
            Создаем новый экземпляр обобщенного класса Container, который реализует базовый
            интерфейсный тип IContainer, закрываем его типом <Shape>, а в качестве входного
            параметра конструктора класса Container передаем экземпляр circle класса Circle,
            который, в свою очередь, наследуется от абстрактного класса Shape. 

            Экземпляр обобщенного класса Container присваивается переменной container типа
            базового обобщенного интерфейсного типа IContainer, закрытого типом <Shape>. Это
            upcast (повышающее приведение) экземпляра класса Container к базовому обобщенному
            интерфейсному типу IContainer.

            Так же над входным параметром (аргументом) конструктора класса 
            Container - экземпляром circle класса Circle производится неявный upcast
            (повышающее приведение) к базовому абстрактному классу Shape, т.к. этот
            тип является параметром класса Container.
            */
            IContainer<Shape> container = new Container<Shape>(circle);
            /*
            Для чего делается апкаст к базовому типу:
            Для начала, общая причина, которая касается не только C#, но и большинства 
            объектно-ориентированных языков: семантика. Если у программиста есть объект конкретного
            типа, он тем не менее может хотеть работать с ним как с более общим объектом: 
            programming against an interface, not implementation!

            Это позволяет убедиться, что в коде не используются лишние, конкретные свойства, что
            будет мешать в будущем обобщить код.

            Разумеется, обычно это слишком строгая цель, и без этого можно обойтись.

            Следующая причина — выбор перегрузки, неполиморфного метода. В зависимости от статического
            типа объекта (при совпадающем динамическом типе) могут быть вызваны различные перегрузки
            при одинаково выглядящем коде.  

            https://ru.stackoverflow.com/questions/433314/%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-upcast-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0
            */

            Console.WriteLine(container.Figure.ToString()); // вывести полную квалификацию имени типа

            Console.ReadKey();
        }
    }
}

/*2020.06.23 21:17 IMM*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// контрвариантность обобщений
// контрвариантность обобщений в C#4.0 ограничена интерфейсами и делегатами
/*
Понятия ковариантности и контравариантности связаны с возможностью использовать в приложении 
вместо некоторого типа другой тип, который находится ниже или выше в иерархии наследования.

Имеется три возможных варианта поведения:
    Ковариантность: позволяет использовать более конкретный тип, чем заданный изначально
    Контравариантность: позволяет использовать более универсальный тип, чем заданный изначально
    Инвариантность: позволяет использовать только заданный тип

Начиная с .NET 4.0 в C# была добавлена возможность создания ковариантных и контравариантных 
обобщенных интерфейсов. Это функциональность повышает гибкость при использовании обобщенных 
интерфейсов в программе. По умолчанию все обобщенные интерфейсы, например, IAccout<T>
являются инвариантными. 
*/

namespace Generics_005
{
    // создадим абстрактный класс
    /*
    Абстрактный класс в объектно-ориентированном программировании — базовый класс, который
    не предполагает создания экземпляров. Абстрактные классы реализуют на практике один из 
    принципов ООП — полиморфизм. Абстрактный класс может содержать (и не содержать) 
    абстрактные методы и свойства. Абстрактный метод не реализуется для класса, в котором
    описан, однако должен быть реализован для его неабстрактных потомков. Абстрактные 
    классы представляют собой наиболее общие абстракции, то есть имеющие наибольший объём
    и наименьшее содержание.  
    */
    public abstract class Shape { }

    // класс, который наследуется от абстрактного класса Shape
    public class Circle : Shape { }

    // открытый интерфейс IContainer, параметризированный одним указателем места заполнения типом - Т,
    // который помечен ключевым словом in - настоящая контрвариантность
    // in определяет использование контрвариантности в обобщениях
    // только интерфейсы и делегаты поддерживают ко/контрвариантность обобщений
    /*
    Абстрактные классы могут содержать в себе реализацию некоторых методов, интерфейсы
    содержат только прототипы. 

    Абстрактный класс — это класс, у которого не реализован один или больше методов 
    (некоторые языки требуют такие методы помечать специальными ключевыми словами).

    Абстрактный класс нужен, когда нужно семейство классов, у которых есть много
    общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать 
    много идентичного кода.

    Интерфейс - это форма взаимодействия с любыми классами, которые его реализуют, а 
    абстрактный класс - это предок, который определяет не только особенности поведения
    (методы), но и некоторые аспекты самого объекта (поля/свойства).
    Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все
    они публичные и нет переменных класса.

    интерфейс - это "что необходимо уметь, чтобы такое можно было создать и называть этим 
    именем ("выполняемый", "перечисляемый", "уничтожаемый", ...)". перефразирую. все, кто
    реализуют интерфейс, обязательно (как-то) умеют делать все, что в описании интерфейса
    перечислено. и больше интерфейс не определяет и не имеет ничего!

    Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, 
    один класс хочет дать другому возможность доступа к некоторым своим методам, но
    не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

    Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.
    */
    public interface IContainer<in T>
    {
        /*
        Первое значение ключевого слова in в языке C#:
        Ключевое in инициирует передачу аргументов по ссылке. В результате этот формальный 
        параметр становится псевдонимом для аргумента, который должен представлять собой 
        переменную. Другими словами, любая операция в параметре осуществляется с аргументом.
        Оно аналогично ключевым словам ref и out, за исключением того, что аргументы in не
        могут быть изменены вызываемым методом. В то время как аргументы ref могут быть
        изменены, аргументы out должны быть изменены вызывающим объектом, и эти изменения
        отслеживаются в вызывающем контексте. 
        
        Второе значение ключевого слова in в языке C#:
        Для параметров универсального типа ключевое слово in указывает, что параметр типа
        является контравариантным. Ключевое слово in может применяться в универсальных
        интерфейсах и делегатах.

        Контравариантность позволяет использовать производные типы со степенью наследования 
        меньше, чем у типа, заданного универсальным параметром. Благодаря этому можно
        осуществлять неявное преобразование классов, реализующих контравариантные интерфейсы,
        и неявное преобразование типов делегатов. Ковариантность и контравариантность 
        поддерживаются для ссылочных типов, но не для типов значений. 
        */
        // в теле интерфейса создаем абстрактное свойство типа указателя места заполнения типом - Т
        T Figure { set; }
    }

    // класс Container, параметризированный одним указателем места заполнения типом - Т,
    // который реализует интерфейс IContainer, параметризированный одним указателем места
    // заполнения типом - Т
    public class Container<T> : IContainer<T>
    {
        private T figure; // закрытое поле типа указателя места заполнения типом - Т

        // конструктор, который принимает один аргумент типа указателя места заполнения типом - Т
        public Container(T figure)
        {
            this.figure = figure;
        }

        /*
        реализация абстрактного свойства из интерфейса IContainer<T> в виде
        свойства только для записи (указывает на контрвариантность обобщения так же, 
        как и ключевое слово in у параметра типа)
        */
        public T Figure
        {
            set { figure = value; } // только для записи
        }

        /*
        переопределение виртуального метода ToString(), которыйнаходится в базовом 
        классе Object
        */
        public override string ToString() 
        {
            return figure.GetType().ToString();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // создаем экземпляр класса Circle, предварительный upcast к базовому типу Shape
            Shape shape = new Circle(); /*1*/

            /*
            Создаем новый экземпляр обобщенного класса Container, который реализует базовый
            интерфейсный тип IContainer, закрываем его типом <Shape>, а в качестве входного
            параметра конструктора класса Container передаем экземпляр shape класса Shape. 

            Экземпляр обобщенного класса Container присваивается переменной container типа
            базового обобщенного интерфейсного типа IContainer, закрытого типом <Circle>. Это
            upcast (повышающее приведение) экземпляра класса Container к базовому обобщенному
            интерфейсному типу IContainer.

            Так же над входным параметром (аргументом) конструктора класса 
            Container - экземпляром shape класса Shape не производится никакого приведения
            типа, т.к. тип параметра shape совпадает с типом Shape параметра класса
            Container.

            Над параметром типа Shape производится downcast (понижающее приведение) к дочернему
            типу Circle 2 после предварительного upcast`а (повышающего приведения) 1 экземпляра
            класса Circle к базовому типу Shape (downcast невозможен без предварительного
            upcast`а).

            Таким образом, downcast (понижающее приведение) параметра типа
            (<Shape> --> <Circle>) реализует контрвариантность - использование более общего
            типа, чем задано изначально. Проще говоря, контрвариантность - это
            downcast параметра типа.

            Без ключевого слова in в определении interface IContainer<in T> в строке ниже 
            будет ошибка - не удается неявно преобразовать тип Shape в тип Circle.
            */
            IContainer<Circle> container = new Container<Shape>(shape); /*2*/
            /*
            Для начала, общая причина, которая касается не только C#, но и большинства 
            объектно-ориентированных языков: семантика. Если у программиста есть объект конкретного
            типа, он тем не менее может хотеть работать с ним как с более общим объектом: 
            programming against an interface, not implementation!

            Это позволяет убедиться, что в коде не используются лишние, конкретные свойства, что
            будет мешать в будущем обобщить код.

            Разумеется, обычно это слишком строгая цель, и без этого можно обойтись.

            Следующая причина — выбор перегрузки, неполиморфного метода. В зависимости от статического
            типа объекта (при совпадающем динамическом типе) могут быть вызваны различные перегрузки
            при одинаково выглядящем коде.  

            https://ru.stackoverflow.com/questions/433314/%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-upcast-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0
            */

            Console.WriteLine(container.ToString()); // вывести полную квалификацию имени типа

            Console.ReadKey();
        }
    }
}

/*2024.12.28 13:39 IMM*/

using System;

// Воскрешение (Resurrection) из мертвых.

namespace Resurrection
{
    internal sealed class SomeType
    {
        /*
        Для работы с объектами, имеющими метод Finalize, CLR использует следующий механизм. При создании объекта, 
        если он содержит метод Finalize, ссылка на него помещается в специальный список, называемый Finalization Queue.
        После того, как GC определяет, что какой-либо объект можно удалить, ссылка на этот объект ищется в 
        Finalization Queue, и если находится, то объект оставляется в покое до следующей сборки мусора, а ссылка на 
        него из Finalization Queue удаляется и добавляется в другой список, называемый F-reachable Queue.
        Далее этим списком занимается специально созданный для этого поток, который по очереди вызывает методы Finalize 
        для объектов из F-reachable Queue, а затем удаляет их и из этого списка.
        Зачем нужны такие сложности? Дело в том, что по идее деструктор вызывается после того, как объект уже никто не 
        использует, но нам никто не мешает прямо в деструкторе сохранить указатель на наш объект в какой-нибудь 
        глобальной переменной и использовать его в дальнейшем без особых угрызений совести. При описанной выше схеме
        с объектом ничего не случится, и им можно будет спокойно пользоваться сколь угодно долго. Единственное отличие
        заключается в том, что после того, как наш объект станет не нужен, метод Finalize для него вызван уже не будет,
        так как ссылка на наш объект уже отсутствует в Finalization Queue. Но, как вы уже догадались, и эта ситуация 
        исправима. Метод ReRegisterForFinalize, который мы используем в нашем примере, как раз и позволяет вернуть наш
        объект обратно в Finalization Queue.
        */
        ~SomeType() // другое название деструктора - метод Finalize
        {
            Console.WriteLine("Finalizer {0}", Program.counter++);

            // В этом случае при вызове метода Finalize объекта SomeType ссылка на него
            // помещается в статическую переменную живого объекта (Program)  
            // и объект (SomeType) становится доступным из кода приложения. 
            // Теперь объект "воскресает", а сборщик мусора не принимает его за мусор.
            Program.Instance = this;

            if (Program.counter < 3)
                // Вызов ReRegisterForFinalize используется для повторного вызова деструктора.
                GC.ReRegisterForFinalize(this);
        }
    }
    class Program
    {
        public static SomeType Instance { get; set; }
        public static int counter;

        static void Main()
        {
            Instance = new SomeType();

            Instance = null; // Освобождение объекта (потеря ссылки).
            GC.Collect(); // Отработает деструктор ~SomeType()

            // Delay.
            Console.ReadKey();

            Instance = null; // Освобождение объекта (потеря ссылки).
            GC.Collect(); // Отработает деструктор ~SomeType()

            // Delay.
            Console.ReadKey();

            // Отработает деструктор ~SomeType()
        }
    }
}

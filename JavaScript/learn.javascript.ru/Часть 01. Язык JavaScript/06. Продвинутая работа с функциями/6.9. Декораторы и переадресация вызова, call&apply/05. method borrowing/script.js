/*2025.04.15 17:53 IMM*/
'use strict';

// Заимствование метода
// Теперь давайте сделаем ещё одно небольшое улучшение функции хеширования:

// function hash(args) {
//   return args[0] + ',' + args[1];
// }
// На данный момент она работает только для двух аргументов. Было бы лучше, если бы она могла склеить любое количество args.

// Естественным решением было бы использовать метод arr.join:

// function hash(args) {
//   return args.join();
// }
// …К сожалению, это не сработает, потому что мы вызываем hash(arguments), а объект arguments является перебираемым и псевдомассивом, но не реальным массивом.

// Таким образом, вызов join для него потерпит неудачу, что мы и можем видеть ниже:

// function hash() {
//   alert( arguments.join() ); // Ошибка: arguments.join не является функцией
// }

// hash(1, 2);
// Тем не менее, есть простой способ использовать соединение массива:

// function hash() {
//   alert( [].join.call(arguments) ); // 1,2
// }

// hash(1, 2);
// Этот трюк называется заимствование метода.

// Мы берём (заимствуем) метод join из обычного массива [].join. И используем [].join.call, чтобы выполнить его в контексте arguments.

// Почему это работает?

// Это связано с тем, что внутренний алгоритм встроенного метода arr.join(glue) очень прост. Взято из спецификации практически «как есть»:

// Пускай первым аргументом будет glue или, в случае отсутствия аргументов, им будет запятая ","
// Пускай result будет пустой строкой "".
// Добавить this[0] к result.
// Добавить glue и this[1].
// Добавить glue и this[2].
// …выполнять до тех пор, пока this.length элементов не будет склеено.
// Вернуть result.
// Таким образом, технически он принимает this и объединяет this[0], this[1]… и т.д. вместе. Он намеренно написан так, что допускает любой псевдомассив this (не случайно, многие методы следуют этой практике). Вот почему он также работает с this=arguments.

// Итого
// Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.

// Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как func.calledCount или типа того, то декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства.

// Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!

// Для реализации cachingDecorator мы изучили методы:

// func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
// func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов.
// В основном переадресация вызова выполняется с помощью apply:

// let wrapper = function(original, arguments) {
//   return original.apply(this, arguments);
// };
// Мы также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments. В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который является реальным массивом.
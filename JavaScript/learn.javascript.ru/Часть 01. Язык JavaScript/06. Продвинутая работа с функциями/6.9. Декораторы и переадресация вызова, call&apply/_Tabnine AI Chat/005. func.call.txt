почему в JS нельзя сразу было сделать так, чтобы контекст this в этом случае не терялся и программисту не приходилось использовать func.call? Зачем эти низкоуровневые проблемы?
Это отличный вопрос! Причины, по которым JavaScript работает таким образом, связаны с историей языка и некоторыми фундаментальными принципами его дизайна. Давайте рассмотрим несколько аспектов:
1.
Историческое наследие:
JavaScript был создан в очень короткие сроки (около 10 дней) Бренданом Эйхом в 1995 году. Некоторые решения, принятые тогда, были продиктованы необходимостью быстрой разработки и соответствия ожиданиям того времени.
2.
Гибкость языка:
JavaScript предоставляет большую гибкость в работе с контекстом выполнения (this). Это позволяет реализовывать различные паттерны программирования, но также может приводить к неожиданному поведению.
3.
Функциональная природа:
В JavaScript функции являются объектами первого класса, что означает, что их можно передавать как аргументы, возвращать из других функций и присваивать переменным. Это мощная возможность, но она также усложняет автоматическое сохранение контекста.
4.
Совместимость и обратная поддержка:
Изменение поведения this могло бы нарушить работу огромного количества существующего кода.
5.
Явное указание контекста:
Методы вроде call, apply и bind предоставляют явный контроль над контекстом, что может быть полезно в определенных ситуациях.
Однако, стоит отметить, что в современном JavaScript есть способы избежать этих проблем:
1.
Стрелочные функции (=>), которые не создают свой собственный контекст this.
2.
Метод bind() для привязки контекста.
3.
Использование классов (введены в ES6), которые автоматически связывают методы с экземпляром.
Например, можно переписать декоратор, используя стрелочную функцию:
function cachingDecorator(func) {
  let cache = new Map();
  
  return (x) => {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x);
    cache.set(x, result);
    return result;
  };
}
Apply
Таким образом, хотя JavaScript и сохраняет некоторые "низкоуровневые проблемы" для обратной совместимости и гибкости, современный язык предоставляет инструменты для их преодоления. Понимание этих особенностей позволяет разработчикам использовать всю мощь языка и избегать потенциальных проблем.
/*2025.03.18 11:48 IMM*/
'use strict';

// Сделаем worker.slow кеширующим
// 1. Объект worker
let worker = {
  // Метод, который всегда возвращает 1
  someMethod() {
    return 1;
  },

  // Медленный метод, который выполняет "тяжелую" работу
  slow(x) {
    // Выводит сообщение о вызове
    alert("Called with " + x);
    // Возвращает x, умноженное на результат someMethod()
    return x * this.someMethod(); // (*)
  }
};

// 2. Функция-декоратор для кеширования
/*
если функция была вызвана с одинаковыми аргументами ранее, она не будет
выполнять вычисления снова, а сразу вернет сохраненный результат
*/
function cachingDecorator(func) {
  // Создаем Map для хранения кеша
  let cache = new Map();
  
  // Возвращаем новую функцию
  return function(x) {
    // Если результат для x уже в кеше, возвращаем его
    if (cache.has(x)) {
      return cache.get(x);
    }
    // Иначе вызываем оригинальную функцию
    let result = func.call(this, x); // теперь 'this' передаётся правильно
    // Сохраняем результат в кеш
    cache.set(x, result);
    // Возвращаем результат
    return result;
  };
}

// 3. Проверка работы оригинального метода
alert( worker.slow(1) ); // Выведет "Called with 1" и вернет 1

// 4. Применение декоратора
worker.slow = cachingDecorator(worker.slow);

// 5. Проверка работы декорированного метода
alert( worker.slow(2) ); // Теперь это должно работать корректно

// Ранее возникала ошибка в строке (*), когда функция пыталась получить доступ к this.someMethod.
// Это происходило потому, что при вызове func(x) внутри декоратора, контекст this терялся.

// Теперь эта проблема решена с помощью func.call(this, x) в декораторе,
// что позволяет правильно передать контекст this в оригинальную функцию.
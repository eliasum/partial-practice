/*2025.03.14 15:42 IMM*/
'use strict';

// Применение «func.call» для передачи контекста

// Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.

// Например, в приведённом ниже коде worker.slow() перестаёт 
// работать после применения декоратора:

// сделаем worker.slow кеширующим
// 1. Объект worker
let worker = {
  // Метод, который всегда возвращает 1
  someMethod() {
    return 1;
  },

  // Медленный метод, который выполняет "тяжелую" работу
  slow(x) {
    // Выводит сообщение о вызове
    alert("Called with " + x);
    // Возвращает x, умноженное на результат someMethod()
    return x * this.someMethod(); // (*)
  }
};

// 2. Функция-декоратор для кеширования
function cachingDecorator(func) {
  // Создаем Map для хранения кеша
  let cache = new Map();
  
  // Возвращаем новую функцию
  return function(x) {
    // Если результат для x уже в кеше, возвращаем его
    if (cache.has(x)) {
      return cache.get(x);
    }
    // Иначе вызываем оригинальную функцию
    let result = func(x); // (**)
    // Сохраняем результат в кеш
    cache.set(x, result);
    // Возвращаем результат
    return result;
  };
}

// 3. Проверка работы оригинального метода
alert( worker.slow(1) ); // Выведет "Called with 1" и вернет 1

// 4. Попытка применить декоратор (закомментирована)
worker.slow = cachingDecorator(worker.slow);

// 5. Проверка работы декорированного метода (закомментирована)
alert( worker.slow(2) ); // Ошибка: не удаётся прочитать свойство 'someMethod' из 'undefined'

// Ошибка возникает в строке (*). Функция пытается получить доступ к this.someMethod
//  и завершается с ошибкой. Видите почему?

// Причина в том, что в строке (**) декоратор вызывает оригинальную функцию как 
// func(x), и она в данном случае получает this = undefined.
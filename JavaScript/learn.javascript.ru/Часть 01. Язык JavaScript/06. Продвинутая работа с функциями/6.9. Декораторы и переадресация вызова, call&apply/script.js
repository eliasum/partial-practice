/*2025.03.12 16:53 IMM*/
'use strict';

/*
Декораторы и переадресация вызова, call/apply

JavaScript предоставляет исключительно гибкие возможности по работе с функциями: 
они могут быть переданы в другие функции, использованы как объекты, и сейчас мы 
рассмотрим, как перенаправлять вызовы между ними и как их декорировать.

Прозрачное кеширование
Представим, что у нас есть функция slow(x), выполняющая ресурсоёмкие вычисления,
но возвращающая стабильные результаты. Другими словами, для одного и того же x 
она всегда возвращает один и тот же результат.

Если функция вызывается часто, то, вероятно, мы захотим кешировать (запоминать) 
возвращаемые ею результаты, чтобы сэкономить время на повторных вычислениях.

Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим 
её в функцию-обёртку – «wrapper» (от англ. «wrap» – обёртывать), которая добавит 
кеширование. Далее мы увидим, что в таком подходе масса преимуществ.

Вот код с объяснениями:
*/ 

function slow(x) {
    // здесь могут быть ресурсоёмкие вычисления
    alert(`Called with ${x}`);
    return x;
  }
  
  function cachingDecorator(func) {
    let cache = new Map();
  
    return function(x) {
      if (cache.has(x)) {    // если кеш содержит такой x,
        return cache.get(x); // читаем из него результат
      }
  
      let result = func(x); // иначе, вызываем функцию
  
      cache.set(x, result); // и кешируем (запоминаем) результат
      return result;
    };
  }
  
  slow = cachingDecorator(slow);
  
  alert( slow(1) ); // slow(1) кешируем
  alert( "Again: " + slow(1) ); // возвращаем из кеша
  
  alert( slow(2) ); // slow(2) кешируем
  alert( "Again: " + slow(2) ); // возвращаем из кеша
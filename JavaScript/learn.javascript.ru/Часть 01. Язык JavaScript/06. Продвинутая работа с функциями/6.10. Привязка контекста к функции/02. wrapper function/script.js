/*2025.05.22 18:29 IMM*/
'use strict';

// Решение 1: сделать функцию-обёртку
// Самый простой вариант решения – это обернуть вызов в анонимную
// функцию, создав замыкание:

let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);

// Теперь код работает корректно, так как объект user достаётся из замыкания, а затем вызывается его метод sayHi.

// То же самое, только короче:

setTimeout(() => user.sayHi(), 1000); // Привет, Вася!

// Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.

// Что произойдёт, если до момента срабатывания setTimeout (ведь задержка составляет целую секунду!) в переменную user будет записано другое значение? Тогда вызов неожиданно будет совсем не тот!

// let user = {
//   firstName: "Вася",
//   sayHi() {
//     alert(`Привет, ${this.firstName}!`);
//   }
// };

// setTimeout(() => user.sayHi(), 1000);

// // ...в течение 1 секунды
// user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };

// // Другой пользователь в 'setTimeout'!
// Следующее решение гарантирует, что такого не случится.
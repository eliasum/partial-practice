/*2025.05.22 15:19 IMM*/
'use strict';

// Привязка контекста к функции
// При передаче методов объекта в качестве колбэков, например для setTimeout, 
// возникает известная проблема – потеря this.

// В этой главе мы посмотрим, как её можно решить.

// ПОТЕРЯ «THIS»

// Мы уже видели примеры потери this. Как только МЕТОД ПЕРЕДАЁТСЯ ОТДЕЛЬНО 
// ОТ ОБЪЕКТА – THIS ТЕРЯЕТСЯ.

// Вот как это может произойти в случае с setTimeout:

let user = {
  firstName: "Вася",
  sayHi() {
    console.log(`Привет, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Привет, undefined!

// При запуске этого кода мы видим, что вызов this.firstName возвращает 
// не «Вася», а undefined!

// Это произошло потому, что setTimeout получил функцию sayHi отдельно от 
// объекта user (именно здесь функция и потеряла контекст). То есть 
// последняя строка может быть переписана как:

let f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли

// Метод setTimeout в браузере имеет особенность: он устанавливает this=window
// для вызова функции (в Node.js this становится объектом таймера, но здесь это 
// не имеет значения). Таким образом, для this.firstName он пытается получить 
// window.firstName, которого не существует. В других подобных случаях this 
// обычно просто становится undefined.

// Задача довольно типичная – мы хотим передать метод объекта куда-то ещё 
// (в этом конкретном случае – в планировщик), где он будет вызван.
// Как бы сделать так, чтобы он вызывался в правильном контексте?
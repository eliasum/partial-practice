/*2020.10.20 16:37 IMM*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    /*
        Финализируемые объекты

    Большинство объектов, используемых в программах на C#, относятся к 
    управляемым или managed-коду, и легко очищаются сборщиком мусора. 
    Однако вместе с тем встречаются также и такие объекты, которые 
    задействуют неуправляемые объекты (низкоуровневые файловые дескрипторы,
    сетевые подключения и т.д.). Такие неуправляемые объекты обращаются к
    API операционной системы через службы PInvoke. Сборщик мусора может 
    справиться с управляемыми объектами, однако он не знает, как удалять 
    неуправляемые объекты. В этом случае разработчик должен сам 
    реализовывать механизмы очистки на уровне программного кода.

    Освобождение неуправляемых ресурсов подразумевает реализацию одного
    из двух механизмов:

        - Создание деструктора

        - Реализация классом интерфейса System.IDisposable

    Создание деструкторов

    Если вы вдруг программировали на языке C++, то наверное уже знакомы
    с концепцией деструкторов. Метод деструктора носит имя класса (как
    и конструктор), перед которым стоит знак тильды (~). Например, 
    создадим деструктор класса Person:
    */
    public class Person
    {
        public string Name { get; set; }

        ~Person()
        {
            Console.Beep();
            Console.WriteLine("Disposed");  // утилизировано
        }

        /*
        Деструктор в отличие от конструктора не может иметь модификаторов 
        доступа. В данном случае в деструкторе в целях демонстрации просто
        вызывается звуковой сигнал и выводится строка на консоль, но в 
        реальных программах в деструктор вкладывается логика освобождения
        неуправляемых ресурсов.

        Однако на деле при очистке сборщик мусора вызывает не деструктор, 
        а метод Finalize класса Person. Все потому, что компилятор C# 
        компилирует деструктор в конструкцию, которая эквивалентна следующей:
        
        protected override void Finalize()
        {
            try
            {
                // здесь идут инструкции деструктора
            }
            finally
            {
                base.Finalize();
            }
        }

        Метод Finalize уже определен в базовом для всех типов классе Object, 
        однако данный метод нельзя так просто переопределить. И фактическая 
        его реализация происходит через создание деструктора.
        */
    }

    class Program
    {
        static void Main(string[] args)
        {
            /*
            Используя в программе класс Person, после ее завершения можно будет
            услышать голосовой сигнал и увидеть на консоли выводимую строку:
            */
            Test();
            GC.Collect();
            Console.ReadLine();
        }

        private static void Test()
        {
            Person p = new Person();
        }
    }
}

/*
Обратите внимание, что даже после завершения метода Test и соответственно
удаления из стека ссылки на объект Person в куче, может не последовать 
немедленного вызова деструктора. Лишь при завершении всей программы 
гарантировано произойдет очистка памяти и вызов деструктора. Поэтому 
для более быстой очистки памяти применяется метод GC.Collect.

На уровне памяти это выглядит так: сборщик мусора при размещении объекта
в куче определяет, поддерживает ли данный объект метод Finalize. И если
объект имеет метод Finalize, то указатель на него сохраняется в 
специальной таблице, которая называется очередь финализации. Когда
наступает момент сборки мусора, сборщик видит, что данный объект должен
быть уничтожен, и если он имеет метод Finalize, то он копируется в еще 
одну таблицу и окончательно уничтожается лишь при следующем проходе 
сборщика мусора.

И здесь мы можем столкнуться со следующей проблемой: а что если нам
немедленно надо вызвать деструктор и освободить все связанные с объектом
неуправляемые ресурсы? В этом случае мы можем использовать второй
подход - реализацию интерфейса IDisposable.
*/

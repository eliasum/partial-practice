/*
Мониторы

Наряду с оператором lock для синхронизации потоков мы можем использовать
мониторы, представленные классом System.Threading.Monitor. Фактически
конструкция оператора lock из прошлой темы инкапсулирует в себе синтаксис
использования мониторов. А рассмотренный в прошлой теме пример будет
эквивалентен следующему коду:
*/
using System;
using System.Threading;

class Program
{
    static int x = 0;

    /*
    объект блокировки или объект синхронизации доступа к разделяемому ресурсу
    из нескольких потоков
    */
    static object locker = new object();

    static void Main(string[] args)
    {
        for (int i = 0; i < 5; i++)
        {
            //Делегат - это объект указывающий на метод.
            //Здесь происходит передача метода Count() новому объекту myThread типа 
            //Thread через новый экземпляр делегата ThreadStart НЕЯВНО (сообщаем метод
            //Count() с делегатом типа ThreadStart). При создании нового потока будет
            //выполняться код из метода Count().
            //Т.е. метод, код которого должен выполняться в другом потоке, передается в 
            //качестве аргумента экземпляру делегата ThreadStart НЕЯВНО, который
            //в свою очередь передается в качестве аргумента экземпляру класса Thread:
            //метод --> экземпляр делегата ThreadStart НЕЯВНО --> объект Thread

            // создаем новый поток (здесь предположение делегата)            
            Thread myThread = new Thread(Count);

            // имя нового потока
            myThread.Name = $"Поток {i.ToString()}";

            // запускаем новый поток
            myThread.Start();
        }

        Console.ReadLine();
    }

    public static void Count()
    {
        bool acquiredLock = false;

        try
        {
            /*
            критическая секция - участок кода, в котором происходит попытка
            доступа к разделяемому ресурсу.
            
            Класс Monitor предоставляет механизм для синхронизации доступа к объектам.
            Метод Monitor.Enter получает монопольную блокировку указанного объекта и
            единым блоком задает значение, указывающее, была ли выполнена блокировка 
            */

            // acquiredLock передается по ссылке

            /*Начало*/
            Monitor.Enter(locker, ref acquiredLock);

            x = 1;

            for (int i = 1; i < 9; i++)
            {
                Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
                x++;
                Thread.Sleep(100);
            }
        }

        /*
        Использование блока finally гарантирует, что некоторый набор операторов
        будет выполняться всегда, независимо от того, возникло исключение
        (любого типа) или нет.
        */
        finally
        {
            /*Конец*/
            if (acquiredLock) Monitor.Exit(locker);
        }
    }
}

/*
Метод Monitor.Enter принимает два параметра - объект блокировки и значение
типа bool, которое указывает на результат блокировки (если он равен true,
то блокировка успешно выполнена). Фактически этот метод блокирует объект 
locker так же, как это делает оператор lock. В блоке 
try...finally с помощью метода Monitor.Exit происходит освобождение объекта
locker, если блокировка осуществлена успешно, и он становится доступным
для других потоков.

Кроме блокировки и разблокировки объекта класс Monitor имеет еще ряд методов,
которые позволяют управлять синхронизацией потоков. Так, метод Monitor.Wait 
освобождает блокировку объекта и переводит поток в очередь ожидания объекта.
Следующий поток в очереди готовности объекта блокирует данный объект. А все 
потоки, которые вызвали метод Wait, остаются в очереди ожидания, пока не
получат сигнала от метода Monitor.Pulse или Monitor.PulseAll, посланного
владельцем блокировки. Если метод Monitor.Pulse отправил сигнал, то поток,
находящийся во главе очереди ожидания, получает сигнал и блокирует 
освободившийся объект. Если же метод Monitor.PulseAll отправлен, то все
потоки, находящиеся в очереди ожидания, получают сигнал и переходят в 
очередь готовности, где им снова разрешается получать блокировку объекта.
*/


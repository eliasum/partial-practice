/*2024.11.19 17:54 IMM*/

using System;
using System.Linq;
using System.Text.RegularExpressions;

// Регулярные выражения.

/*
   МЕТАСИМВОЛЫ - это символы для составления Шаблона поиска.
       
  \d    Определяет символы цифр. 
  \D 	Определяет любой символ, который не является цифрой. 
  \w 	Определяет любой символ цифры, буквы или подчеркивания. 
  \W    Определяет любой символ, который не является цифрой, буквой или подчеркиванием. 
  \s 	Определяет любой непечатный символ, включая пробел. 
  \S 	Определяет любой символ, кроме символов табуляции, новой строки и возврата каретки.
   .    Определяет любой символ кроме символа новой строки. 
  \.    Определяет символ точки.
 
  
  КВАНТИФИКАТОРЫ - это символы которые определяют, где и сколько раз необходимое 
  вхождение символов может встречаться.
 
  ^ - c начала строки. 
  $ - с конца строки. 
  + - одно и более вхождений подшаблона в строке.  
 

  Match представляет подстроку соответсвующую шаблону.
  Match.Success - булево значение, которое показывает найдено вхождение или нет.
  Все переменные обьявленные в шаблоне( (?<mylink>) и (?<mylnktext>) ) хранятся
  в колекции Mathes.Groups.
  В нашем случае нам придется использовать m.Groups["mylink"] и 
  m.Groups["mylnktext"], для вывода значения каждой переменной. 
*/

namespace RegularExpressions7
{
    class Program
    {
        static void Main()
        {
            string input = "";
            input += "<a href='http://cbsystematics.com'>Home-page</a>";
            input += "<a href='http://google.com'>Search</a>";
            input += "<a href='https://ya.ru'>Yandex</a>";
            input += "<a href='https://yandex.ru'>Yandex Full</a>";
            input += "<a href='http://microsoft.com'>Microsoft</a>";

            /*
            Создаем экземпляр класса Regex и передаем в качестве аргумента конструктора
            шаблон pattern, который состоит из переменной (?<link>\S+) с именем link и
            переменной (?<text>\S+) с именем text, в которых встречается один или 
            несколько + любых символов, кроме символов табуляции, новой строки и 
            возврата каретки. Между переменными знак >.
            */
            var regex = new Regex(@"href='(?<link>\S+)'>(?<text>\S+)</a>");

            // вывод всей строки с ссылками
            Console.WriteLine(input+'\n');

            /* --1--
            Как только найдено (m.Success) в указанной входной строке input первое 
            вхождение регулярного выражения regex.Match(input), указанного в 
            конструкторе System.Text.RegularExpressions.Regex, то вывести результат 
            итерации и вернуть новый объект System.Text.RegularExpressions.Match с
            результатами для следующего сопоставления, начиная с позиции, на которой
            завершилось последнее сопоставление (с символа после последнего 
            сопоставленного символа).
            */
            // for(текущее_значение_m; условие; действие_при_каждой_итерации).
            for (Match m = regex.Match(input); m.Success; m = m.NextMatch())
            {
                // {0,-25} - значит что выделить 25 знакомест консоли под вывод {0}.
                // (-) - значит "прижаться" влево :)
                Console.WriteLine("ССЫЛКА: {0,-25} на: {1,-4} позиции с именем: {2}", 
                    m.Groups["link"],
                    /*
                    Позиция в исходной строке, в которой обнаружен первый символ
                    записанной подстроки.
                    */
                    m.Groups["link"].Index,
                    m.Groups["text"]);
            }

            Console.WriteLine(new string('-', 25));

            /* --2--
            Перебор всех вхождений регулярного выражения в указанной строке
            */
            foreach (Match m in regex.Matches(input))
            {
                // {0,-25} - значит что выделить 25 знакомест консоли под вывод {0}.
                // (-) - значит "прижаться" влево :)
                Console.WriteLine("ССЫЛКА: {0,-25} на: {1,-4} позиции с именем: {2}", 
                    m.Groups["link"],
                    /*
                    Позиция в исходной строке, в которой обнаружен первый символ
                    записанной подстроки.
                    */
                    m.Groups["link"].Index,
                    m.Groups["text"]);
            }

            Console.WriteLine(new string('-',20));

            /* --3-- LINQ*/
            var htmlQuery = from Match m in regex.Matches(input)
                            where m.Groups["link"].Value.StartsWith("https")
                            select m;

            foreach (var m in htmlQuery)
            {
                Console.WriteLine("ССЫЛКА: {0,-25} на: {1,-4} позиции с именем: {2}", 
                    m.Groups["link"],
                    m.Groups["link"].Index,
                    m.Groups["text"]);
            }
            // Delay.
            Console.ReadKey();
        }
    }
}

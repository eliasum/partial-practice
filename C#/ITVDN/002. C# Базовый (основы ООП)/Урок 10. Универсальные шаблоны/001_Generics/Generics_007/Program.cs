/*2020.06.23 19:49 IMM*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// ковариантность обобщений
/*
Понятия ковариантности и контравариантности связаны с возможностью использовать в приложении 
вместо некоторого типа другой тип, который находится ниже или выше в иерархии наследования.

Имеется три возможных варианта поведения:
    Ковариантность: позволяет использовать более конкретный тип, чем заданный изначально
    Контравариантность: позволяет использовать более универсальный тип, чем заданный изначально
    Инвариантность: позволяет использовать только заданный тип

Начиная с .NET 4.0 в C# была добавлена возможность создания ковариантных и контравариантных 
обобщенных интерфейсов. Это функциональность повышает гибкость при использовании обобщенных 
интерфейсов в программе. По умолчанию все обобщенные интерфейсы, например, IAccout<T>
являются инвариантными. 
*/

namespace Generics_005
{
    // создадим абстрактный класс
    /*
    Абстрактный класс в объектно-ориентированном программировании — базовый класс, который
    не предполагает создания экземпляров. Абстрактные классы реализуют на практике один из 
    принципов ООП — полиморфизм. Абстрактный класс может содержать (и не содержать) 
    абстрактные методы и свойства. Абстрактный метод не реализуется для класса, в котором
    описан, однако должен быть реализован для его неабстрактных потомков. Абстрактные 
    классы представляют собой наиболее общие абстракции, то есть имеющие наибольший объём
    и наименьшее содержание.  
    */
    public abstract class Shape { }

    // класс, который наследуется от абстрактного класса Shape
    public class Circle : Shape { }

    // открытый интерфейс IContainer, параметризированный одним указателем места заполнения типом - Т,
    // который помечен ключевым словом out - настоящая ковариантность
    // out определяет использование ковариантности в обобщениях
    /*
    Абстрактные классы могут содержать в себе реализацию некоторых методов, интерфейсы
    содержат только прототипы. 

    Абстрактный класс — это класс, у которого не реализован один или больше методов 
    (некоторые языки требуют такие методы помечать специальными ключевыми словами).

    Абстрактный класс нужен, когда нужно семейство классов, у которых есть много
    общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать 
    много идентичного кода.

    Интерфейс - это форма взаимодействия с любыми классами, которые его реализуют, а 
    абстрактный класс - это предок, который определяет не только особенности поведения
    (методы), но и некоторые аспекты самого объекта (поля/свойства).
    Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все
    они публичные и нет переменных класса.

    интерфейс - это "что необходимо уметь, чтобы такое можно было создать и называть этим 
    именем ("выполняемый", "перечисляемый", "уничтожаемый", ...)". перефразирую. все, кто
    реализуют интерфейс, обязательно (как-то) умеют делать все, что в описании интерфейса
    перечислено. и больше интерфейс не определяет и не имеет ничего!

    Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, 
    один класс хочет дать другому возможность доступа к некоторым своим методам, но
    не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

    Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.
    */
    public interface IContainer<out T>
    {
        /*
        Первое значение ключевого слова out в языке C#:
        ключевые слова ref и out в C#. Использование этих ключевых слов приводит к тому, что 
        параметр начинает передаваться не по значению, а по ссылке. Ключевое слово out 
        обозначает почти то же самое, что и ref. Параметр, перед которым указываются данные
        операторы, тоже передаётся по ссылке, т.е. в переменной хранится адрес этого 
        параметра. В чем разница же между ref и out? Разница в том, что out позволяет вам
        передать ссылку на переменную неинициализированную, а ref — только на 
        инициализированную.

        Второе значение ключевого слова out в языке C#:
        Для параметров универсального типа ключевое слово out указывает, что параметр типа 
        является ковариантным. Ключевое слово out может применяться в универсальных 
        интерфейсах и делегатах.

        Ковариация позволяет использовать производные типы со степенью наследования больше, 
        нежели у типа, заданного универсальным параметром. Благодаря этому можно осуществлять
        неявное преобразование классов, реализующих ковариантные интерфейсы, и неявное 
        преобразование типов делегатов. Ковариация и контравариантность поддерживаются
        для ссылочных типов, но не для типов значений.
        */
        // в теле интерфейса создаем абстрактное свойство типа указателя места заполнения типом - Т
        T Figure { get; }
    }

    // класс Container, параметризированный одним указателем места заполнения типом - Т,
    // который реализует интерфейс IContainer, параметризированный одним указателем места
    // заполнения типом - Т
    public class Container<T> : IContainer<T>
    {
        private T figure; // закрытое поле типа указателя места заполнения типом - Т

        // конструктор, который принимает один аргумент типа указателя места заполнения типом - Т
        public Container(T figure)
        {
            this.figure = figure;
        }

        /*
        реализация абстрактного свойства из интерфейса IContainer<T> в виде
        свойства только для чтения (указывает на ковариантность обобщения так же, 
        как и ключевое слово out у параметра типа)
        */
        public T Figure
        {
            get { return figure; }  
        }  
    }

    class Program
    {
        static void Main(string[] args)
        {
            // создаем экземпляр класса Circle
            Circle circle = new Circle();

            /*
            Создаем новый экземпляр обобщенного класса Container, который реализует базовый
            интерфейсный тип IContainer, закрываем его типом <Circle>, а в качестве входного
            параметра конструктора класса Container передаем экземпляр circle класса Circle,
            который, в свою очередь, наследуется от абстрактного класса Shape. 

            Экземпляр обобщенного класса Container присваивается переменной container типа
            базового обобщенного интерфейсного типа IContainer, закрытого типом <Shape>. Это
            upcast (повышающее приведение) экземпляра класса Container к базовому обобщенному
            интерфейсному типу IContainer.

            Так же над входным параметром (аргументом) конструктора класса 
            Container - экземпляром circle класса Circle не производится никакого приведения
            типа, т.к. тип параметра circle совпадает с типом Circle параметра класса
            Container.

            Над параметром типа Circle производится upcast (повышающее приведение) к базовому
            типу Shape.

            Таким образом, upcast (повышающее приведение) параметра типа (<Circle> --> <Shape>)
            реализует ковариантность - использование более конкретного типа, чем задано
            изначально. Проще говоря, ковариантность - это upcast параметра типа.

            Без ключевого слова out в определении interface IContainer<out T> в строке ниже 
            будет ошибка - не удается неявно преобразовать тип Circle в тип Shape.
            */
            IContainer<Shape> container = new Container<Circle>(circle);
            /*
            Для начала, общая причина, которая касается не только C#, но и большинства 
            объектно-ориентированных языков: семантика. Если у программиста есть объект конкретного
            типа, он тем не менее может хотеть работать с ним как с более общим объектом: 
            programming against an interface, not implementation!

            Это позволяет убедиться, что в коде не используются лишние, конкретные свойства, что
            будет мешать в будущем обобщить код.

            Разумеется, обычно это слишком строгая цель, и без этого можно обойтись.

            Следующая причина — выбор перегрузки, неполиморфного метода. В зависимости от статического
            типа объекта (при совпадающем динамическом типе) могут быть вызваны различные перегрузки
            при одинаково выглядящем коде.  

            https://ru.stackoverflow.com/questions/433314/%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-upcast-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0
            */

            Console.WriteLine(container.Figure.ToString()); // вывести полную квалификацию имени типа

            Console.ReadKey();
        }
    }
}
